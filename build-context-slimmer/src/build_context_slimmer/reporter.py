from pathlib import Path
from typing import Dict, Any, List
from rich.console import Console, ConsoleOptions
from rich.table import Table
from rich.text import Text
from rich import box

import humanize


def format_bytes(n: int) -> str:
    return humanize.naturalsize(n)


def print_report(
    context: Path, all_sizes: Dict[Path, int], used_sizes: Dict[Path, int], console: Console
) -> Dict[str, Any]:
    total_files = len(all_sizes)
    used_files = len(used_sizes)
    unused_files = total_files - used_files

    total_size = sum(all_sizes.values())
    used_size = sum(used_sizes.values())
    unused_size = total_size - used_size

    savings_pct = ((unused_size / total_size) * 100) if total_size else 0

    stats = {
        "total_files": total_files,
        "used_files": used_files,
        "unused_files": unused_files,
        "total_size_bytes": total_size,
        "used_size_bytes": used_size,
        "unused_size_bytes": unused_size,
        "savings_pct": round(savings_pct, 1),
    }

    # Header
    console.print(
        Text.from_markup(
            f"\n[b bold blue]\uf3dd Build Context Analysis[/]: {context.name}\n"
        )
    )

    table = Table(box=box.ROUNDED, title="Stats", show_header=True, header_style="bold magenta")
    table.add_column("Metric", style="cyan")
    table.add_column("Value", justify="right")

    table.add_row("Total files", str(total_files))
    table.add_row("Used", f"{used_files} ({used_files/total_files*100:.0f}%)")
    table.add_row("Unused", f"{unused_files} ({savings_pct:.0f}%)")
    table.add_row("Total size", format_bytes(total_size))
    table.add_row("Used", format_bytes(used_size))
    table.add_row("Unused", format_bytes(unused_size))

    console.print(table)

    if savings_pct > 0:
        console.print(
            f"[bold green]ðŸš€ {savings_pct:.0f}% savings ({format_bytes(unused_size)} freed) â†’ {savings_pct/7:.0f}x faster builds![/bold green]"
        )

    # Top unused
    unused_sizes = {p: all_sizes[p] for p in set(all_sizes) - set(used_sizes)}
    top_unused = sorted(unused_sizes.items(), key=lambda x: x[1], reverse=True)[:10]

    if top_unused:
        utable = Table(title="Top 10 Unused (by size)", box=box.MINIMAL)
        utable.add_column("Path", style="green")
        utable.add_column("Size", justify="right")
        utable.add_column("% Total", justify="right")

        for path, size in top_unused:
            pct = (size / total_size) * 100
            rel = path.relative_to(context)
            utable.add_row(str(rel), format_bytes(size), f"{pct:.1f}%")

        console.print(utable)

    return stats


def generate_dockerignore(unused_paths: set[Path], context: Path) -> str:
    """Generate .dockerignore lines covering unused_paths."""
    ignores = set()
    path_to_rel: Dict[Path, str] = {}

    for p in unused_paths:
        rel = p.relative_to(context).as_posix()
        ignores.add(rel)
        path_to_rel[p] = rel

    # Optimize: full unused dirs
    dir_counts = defaultdict(int)
    for p in unused_paths:
        for parent in p.parents:
            if parent.resolve() in path_to_rel:
                continue
            dir_counts[parent] += 1

    # Simple: all unused files + trailing / for dirs if fully unused
    lines = sorted(ignores)
    return "# Auto-generated by build-context-slimmer\n# Regenerate with: build-context-slimmer scan --write-ignore\n" + "\n".join(lines) + "\n"
